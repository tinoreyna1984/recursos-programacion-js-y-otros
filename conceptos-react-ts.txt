React + Typescript
******************

Crear proyecto
==============

Con CRA:

npx create-react-app my-app --template typescript

Con Vite:

Emplear: npm create vite

Genera la siguiente salida verbosa:

√ Project name: ... vite-prueba <- ingresar nombre de proyecto
√ Select a framework: » react <- seleccionar React
√ Select a variant: » react-ts <- seleccionar React con Typescript

Scaffolding project in E:\JavaScript\react\vite-prueba...

Done. Now run:

  cd vite-prueba
  npm install
  npm run dev

El proyecto queda listo. Ejecutar los comandos indicados en la salida.

Adicionalmente, instalar tipos de datos para Node (solo para desarrollo):

npm install @types/node --save-dev

Hooks
=====

useState
--------

Notar que se considera el tipado estricto de TS:

import { useState } from "react";

export const Counter = () => {
  const valorInicial = 0;
  const [counter, setCounter] = useState(valorInicial);

  // TS - tipado estricto. En este caso no devuelve nada, pero el ingreso es un numero
  const incrementar = (numero: number = 1): void => {
    setCounter(counter + numero);
  };

  return (
    <div className="mt-5">
      <h3>useState - React + TS</h3>
      <span>Valor: {counter}</span>
      <br />
      <button
        className="btn btn-outline-light mt-2"
        onClick={() => incrementar()}
      >
        +1
      </button>
      <button
        className="btn btn-outline-light mt-2 ms-2"
        onClick={() => incrementar(2)}
      >
        +2
      </button>
      <button
        className="btn btn-outline-light mt-2 ms-2"
        onClick={() => setCounter(valorInicial)}
      >
        +Borrar
      </button>
    </div>
  );
};


Usuario.tsx:

import { useState } from "react";

// Tipado abstracto de TS - interface
interface User {
  uid: string;
  name: string;
}

export const Usuario = () => {
  const [user, setUser] = useState<User>(); // la interfaz aplica aqui

  const login = () => {
    setUser({
      uid: "123456",
      name: "Tino",
    });
  };

  return (
    <div className="mt-3">
      <h3>Usuario: useState</h3>
      <button className="btn btn-outline-primary" onClick={login}>
        Login
      </button>
      {
        (!user)
        ? <pre className="mt-1">Presione Login</pre>
        : <pre className="mt-1">{JSON.stringify(user)}</pre>
      }
    </div>
  );
};


useEffect + useRef + custom props
---------------------------------

TimerPadre.tsx:

import React from "react";
import { Timer } from "./Timer";
import { useState } from "react";

/**
 * Uso del useEffect y useRef
 */

export const TimerPadre = () => {
  const [milisegundos, setMilisegundos] = useState(1000);

  return (
    <>
      <span>Milisegundos: {milisegundos}</span>
      <br />
      <button
        className="btn btn-primary me-2 mt-1 mb-1"
        onClick={() => setMilisegundos(1000)}
      >
        1000
      </button>
      <button
        className="btn btn-success mt-1 mb-1"
        onClick={() => setMilisegundos(2000)}
      >
        2000
      </button>
      <Timer milisegundos={milisegundos} />
    </>
  );
};


Timer.tsx:

import { useState, useEffect, useRef } from "react";

type TimerArgs = {
  milisegundos: number;
};

export const Timer = ({ milisegundos }: TimerArgs) => {
  const [segundos, setSegundos] = useState(0);
  const ref = useRef<any>();

  useEffect(() => {
    ref.current && clearInterval(ref.current);
    ref.current = setInterval(() => {
      setSegundos((s) => s + 1);
    }, milisegundos);
  }, [milisegundos]);

  return (
    <>
      <h4>
        Timer: <small>{segundos}</small>
      </h4>
    </>
  );
};


useReducer
----------

ContadorRed.tsx:

import { useReducer } from "react";

/**
 * Uso del useReducer y todo lo referente a cambios de estado esenciales
 */

const initialState = {
  contador: 10,
};

// tipo de acción que se puede emitir (action.type)
// tipado obligatorio para el payload
type ActionType =
  | { type: "incrementar" }
  | { type: "decrementar" }
  | { type: "custom"; payload: number };

// notar que se usa el tipado de acciones
const contadorReducer = (state: typeof initialState, action: ActionType) => {
  switch (action.type) {
    case "incrementar":
      return {
        ...state,
        contador: state.contador + 1,
      };

    case "decrementar":
      return {
        ...state,
        contador: state.contador - 1,
      };

    case "custom":
      return {
        ...state,
        contador: action.payload,
      };

    default:
      return state;
  }
};

export const ContadorRed = () => {

  //const [ contadorState, dispatch] = useReducer(contadorReducer, initialState);
  const [{ contador }, dispatch] = useReducer(contadorReducer, initialState);

  return (
    <>
      <h2>Contador: {contador}</h2>
      <button
        className="btn btn-outline-primary mt-1 mb-4 me-2"
        onClick={() => dispatch({ type: "incrementar" })}
      >
        +1
      </button>
      <button
        className="btn btn-outline-primary mt-1 mb-4 me-2"
        onClick={() => dispatch({ type: "decrementar" })}
      >
        -1
      </button>

      <button
        className="btn btn-outline-danger mt-1 mb-4"
        onClick={() => dispatch({ type: "custom", payload: 100 })}
      >
        100
      </button>
    </>
  );
};


Custom hooks
------------

FormData.ts:

/**
 * Interfaz es un concepto de Typescript
 */

export interface FormData {
  email: string;
  nombre: string;
  edad: number;
}

useForm.ts:

import { ChangeEvent, useState } from "react";

// T se emplea para referenciar una interfaz definida
// en el tipo de dato del objeto JSX
export const useForm = <T extends Object>(initState: T) => {
  const [formulario, setFormulario] = useState(initState);

  // siempre es recomendado desestructurar el evento
  //const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
  const handleChange = ({ target }: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = target;
    setFormulario({
      ...formulario,
      [name]: value,
    });
  };

  return { formulario, handleChange, ...formulario };
};

Formulario.tsx:

import { useForm } from "../hooks/useForm";
import { FormData } from "./FormData";

export const Formulario = () => {
  const {email, nombre, edad, formulario, handleChange} = useForm<FormData>({
    email: '',
    nombre: '',
    edad: 0
  });

  return (
    <form autoComplete="off">
      <div className="mb-3">
        <label className="form-label">Email: </label>
        <input
          type="email"
          className="form-control"
          name="email"
          placeholder="Email"
          value={email}
          onChange={handleChange}
        />
      </div>
      <div className="mb-3">
        <label className="form-label">Nombre: </label>
        <input
          type="text"
          className="form-control"
          name="nombre"
          placeholder="Nombre"
          value={nombre}
          onChange={handleChange}
        />
      </div>
      <div className="mb-3">
        <label className="form-label">Edad: </label>
        <input
          type="number"
          className="form-control"
          name="edad"
          placeholder="Edad"
          value={edad}
          onChange={handleChange}
        />
      </div>
      <pre>{JSON.stringify(formulario)}</pre>
    </form>
  );
};



Contextos: useContext, createContext, ContextProvider
-----------------------------------------------------



