Conceptos clave y distintivos de React JS
=========================================

Componente
----------

Es todo objeto que se visualiza en la aplicación web. Ejemplo:

import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className="App">
      <h1>Hola mundo</h1>
    </div>
  );
}

export default App;

Al crear un proyecto React JS, por defecto crea el componente principal App.js. Si se desea crear un componente principal alternativo, se crearía un archivo de JavaScript y se definiría como sigue:

import logo from './logo.svg';
import './App.css';

function MiComponente() {
  return (
    <div className="App">
      <h1>Hola mundo</h1>
    </div>
  );
}

export default MiComponente;

Renderización del componente principal
--------------------------------------

import React from "react";
import { createRoot } from "react-dom/client"; // ahora se exige en React 18
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

/**
 * Notar que ya no se invoca a la clase ReactDOM ni al metodo render
 * como tradicionalmente se hacía hasta la version 17.
 */
const root = createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

Siguiendo el ejemplo anterior, el componente principal creado, al renderizarse, podría ser MiComponente, el cual podría aparecer de la siguiente forma:

const root = createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <MiComponente />
  </React.StrictMode>
);


Propiedades o "props"
---------------------

Es el concepto clave de React. Los props son, simplemente, las propiedades de un componente hecho en React JS, del mismo modo que conocemos los tags de un bloque HTML como, por ejemplo, el de imagen:

<img src=".png" alt="" border="0" align="left" width="" height="" />

En términos de JSX, img sería un componente y los tags src, alt, border, align, width y height serían los props.

Si, por ejemplo, tenemos un componente llamado Persona en JSX (en App.js o donde se llame al componente):

<Persona nombre="Tino" edad=37 />

Los props serían nombre y edad. En la definición de componente sería:

export function Persona(){
	
	return(
		<>
			Nombre: {this.props.nombre} <br/>
			Edad: {this.props.edad}
		</>
	);
	
}

o, más típicamente:

export function Persona(props){
	
	return(
		<>
			Nombre: {props.nombre} <br/>
			Edad: {props.edad}
		</>
	);
	
}

Pueden tener valores por defecto a través de la creación del objeto defaultProps:

Persona.defaultProps = {
	nombre : "Usuario",
	edad : 25,
}

Los props pueden también recibirse como objeto:

Sea:

const persona = {
nombre: "Tino",
edad: 37,
correo: 'tinoreyna1984@gmail.com'
};

Pasamos persona a un componente como este (en App.js o donde se llame al componente):

<Persona persona={persona} />

El componente leerá la persona de la siguiente forma:

export function Persona(props){
	return(
		<>
			Nombre: {props.persona.nombre} <br/>
			Edad: {props.persona.edad} <br/>
			Correo: {props.persona.correo} 
		</>
	);
}

o:

export function Persona(props){

	// la forma más limpia: desestructurando objetos
	{persona} = props;
	{nombre, edad, correo} = persona;
	
	return(
		<>
			Nombre: {nombre} <br/>
			Edad: {edad} <br/>
			Correo: {correo} 
		</>
	);
}

Los props también pueden incluir funciones:

Sea la función declarada en App.js o en otro componente:

const saludoFn = (nombre) => {
	alert("Hola, " + nombre);
};

Sea el componente declarado en App.js o en otro componente:

<Saludo persona={persona} saludoFn={saludoFn} />

El componente sería el siguiente:

export default function Saludo(props) {

  // Notese que las variables las he obtenido con el operador desestructuracion (llaves)

  const { saludoFn, persona } = props;
  const { nombre = 'Usuario' } = persona; // se le puede asignar tambien un valor por defecto de esta forma

  return (
    <>
      <button onClick={() => saludoFn(nombre)}>Saludar</button>
      {/* el componente genera un botón que emplea un callback, aprovechando la función procedente del props */}
    </>
  );
}

Proptypes
=========

Instalación:
npm i prop-types

Manejo de eventos
=================

Se tocará lo más típico:

import React, { useState } from "react";
import PropTypes from "prop-types";

export default function AddCategory({setCategories}) {
  // hooks para el campo de texto
  const [inputValue, setInputValue] = useState("");

  // cada vez que cambio el valor en el campo de texto
  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };

  // cada vez que doy enter o cliquee en algun boton para enviar el dato del formulario
  const handleSubmit = (e) => {
    e.preventDefault();
    if(inputValue.trim().length > 2){
        setCategories(categories => [inputValue, ...categories]);
        setInputValue('');
    }
    
  }

  return (
    <form onSubmit={handleSubmit}>
        <input type="text" value={inputValue} onChange={handleInputChange} />
    </form>
  );
}

onChange: evento propio de cambios en campos de texto. Se invoca un callback que determine el valor mapeado en el instante en el que se introduce un nuevo valor en ese objeto.
onSubmit: es para el envío de un conjunto de valores desde formulario.
onClick: ocurre cuando se hace click en un objeto del tipo botón.

Hooks
=====

Referencias:
https://es.reactjs.org/docs/hooks-state.html
https://es.reactjs.org/docs/hooks-effect.html

Son funcionalidades que permiten cambiar dinámica y sencillamente los estados de los props.

Los más típicos son useState y useEffect, los cuales manejan estados y efectos resultantes de los estados, respectivamente.

Reglas de Hooks:

1. Solo llamar Hooks en el nivel superior. No llamar Hooks dentro de loops, condiciones o funciones anidadas.
2. Solo llamar Hooks desde componentes de función de React. No llamar Hooks desde las funciones regulares de JavaScript. (Solo hay otro lugar válido para llamar Hooks: los Hooks personalizados por el usuario).

Referencia: https://es.reactjs.org/docs/hooks-rules.html

useState
--------

Ejemplo:

import React, { useState } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
       Click me
      </button>
    </div>
  );
}

Línea 1: Importamos el Hook useState desde React que nos permite mantener un estado local en un componente de función.

Línea 4: Dentro del componente Example declaramos una nueva variable de estado llamando al Hook useState. Este nos devuelve un par de valores, a los que damos un nombre. Llamamos count a nuestra variable porque guarda el número de clicks en el botón. La inicializamos a cero pasando 0 como único argumento a useState. El segundo elemento retornado es una función que nos permite actualizar count, por lo que le llamamos setCount.

Línea 9: Cuando el usuario hace click, llamamos a setCount con un nuevo valor. React actualizará entonces el componente Example pasándole el nuevo valor de count.

La logica del useState puede ser definida como la siguiente función:

const useState = (valor) => {
    return [valor, (valor) => {function(valor)}];
}

Para el ejemplo anterior:

/* eslint-disable react-hooks/rules-of-hooks */
import React from 'react';

function Example() {
  const useState = (count) => {
    return [count, (count) => setCount(count)];
  }

  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
       Click me
      </button>
    </div>
  );
}

useEffect
---------

import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // De forma similar a componentDidMount y componentDidUpdate
  useEffect(() => {
    // Actualiza el título del documento usando la API del navegador
    document.title = `Hiciste clic ${count} veces`;
  }, [count]); // count es la única condición que permite la ejecución del hook

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

El useEffect nos permite ejecutar un efecto secundario cuando algo sucede en el componente.

Este fragmento está basado en el ejemplo de contador de la página anterior, pero le hemos añadido una funcionalidad nueva: actualizamos el título del documento con un mensaje personalizado que incluye el número de clicks.

El useEffect nos permite ejecutar una instrucción de forma condicionada. El primer argumento es lo que se desea presentar en el renderizado y el segundo argumento es la lista de condiciones por las cuales se permite la ejecución.

useRef
------

Usa el concepto de referencia de un componente, esto es, el atributo ref de un objeto HTML. Se emplea una variable para inicializar con el hook useRef y aprovecharla ante un evento asociado al objeto en cuestión.

Ejemplo:

import React, { useRef } from "react";
import "./effects.css";

export const FocusScreen = () => {
  /**
   * useRef permite almacenar el valor del elemento de foco en una variable
   */
  const inputRef = useRef();
  const handleClick = () => {
    inputRef.current.select();
  };

  return (
    <div>
      <h1>FocusScreen</h1>
      <hr />
      <input
        ref={inputRef}
        className="form-control"
        placeholder="escribe tu nombre"
      />
      <button className="btn btn-outline-primary mt-5" onClick={handleClick}>
        Focus
      </button>
    </div>
  );
};

useLayoutEffect
---------------

Funciona como el useEffect, pero el efecto generado ocurre después de todas las mutaciones en el DOM.
La sintaxis es similar al useEffect.

useMemo
-------

Permite almacenar el valor de la ejecución de un proceso, el cual ocurre de manera controlada.
El nombre del hook viene a que este memoriza ese proceso para optimizar el desempeño del app (evita posibles llamadas recurrentes a cambios de estado que obliguen a renderizar varias veces el componente).

Ejemplo:

import React, { useMemo, useState } from "react";
import "./effects.css";
import { useCounter } from "../../hooks/useCounter";
import { procesoPesado } from "../../helpers/procesoPesado";

export const MemoHook = () => {
  const { counter, increment } = useCounter(5000);
  const [show, setShow] = useState(true);

  /**
   * useMemo: hook que permite devolver un valor memorizado a partir de un proceso
   * y un conjunto de condiciones que lo controlan
   */
  const memoProcesoPesado = useMemo(() => procesoPesado(counter), [counter]);

  return (
    <div>
        <h1>MemoHook</h1>
      <h3>
        Counter: <small>{counter}</small>
      </h3>
      <hr />
      <p>{memoProcesoPesado}</p>
      <button className="btn btn-primary" onClick={increment}>
        +1
      </button>
      <button
        className="btn btn-outline-primary ml-3"
        onClick={() => setShow(!show)}
      >
        Show/hide {JSON.stringify(show)}
      </button>
    </div>
  );
};

useCallback
-----------

Devuelve un callback memorizado.
Ejemplo:

ShowIncrement.js:

import React from "react";

export const ShowIncrement = React.memo(({ increment }) => {
  console.log("Me volví a generar.");
  return (
    <button
      className="btn btn-outline-primary"
      onClick={() => {
        increment(5);
      }}
    >
      Incrementar
    </button>
  );
});

CallbackHook.js:

import React, { useCallback, useState } from "react";
import "./effects.css";
import { ShowIncrement } from "./ShowIncrement";

export const CallbackHook = () => {
  const [counter, setCounter] = useState(10);

  /* const increment = () => {
    setCounter(counter + 1);
  }; */

  /**
   * useCallback: devuelve un callback memorizado
   */
  const increment = useCallback(
    (num) => {
        setCounter((c) => c + num);
    },
    [setCounter],
  )
  

  return (
    <div>
      <h1>useCallbackHook: {counter}</h1>
      <hr />
      <ShowIncrement increment={increment} />
    </div>
  );
};

Archivos de barril
==================

Consiste en usar un index.js que exporte todos los componentes de una carpeta. Por ejemplo, si tenemos la carpeta components así:

> components
---- AddCategory
---- GifGrid
---- GifItem

En esa carpeta se puede crear un index.js con el siguiente contenido:

export * from './GifGrid';
export * from './GifItem';
export * from './AddCategory';

Esto permite usar más de un componente de una carpeta específica:

import { AddCategory, GifGrid} from "./components";


React.memo
==========

Optimiza el renderizado de un componente con los mismos valores de props ingresados.
Ejemplo:

Small.js:

import React from 'react';

export const Small = React.memo(({value}) => {
  console.log("Me volvi a llamar");
  return (
    <small>{value}</small>
  )
});

Memorize.js: (llama al componente memorizado Small)

import React, { useState } from "react";
import "./effects.css";
import { useCounter } from "../../hooks/useCounter";
import {Small} from "./Small";

export const Memorize = () => {
  const { counter, increment } = useCounter(10);
  const [show, setShow] = useState(true);

  return (
    <div>
      <h1>
        Counter: <Small value={counter} />{" "}
      </h1>
      <hr />
      <button className="btn btn-primary" onClick={increment}>
        +1
      </button>
      <button
        className="btn btn-outline-primary ml-3"
        onClick={() => setShow(!show)}
      >
        Show/hide {JSON.stringify(show)}
      </button>
    </div>
  );
};

Reducers: definición y uso del hook useReducer
==============================================

Un reducer:
1. Es una función corriente que no puede ser asíncrona.
2. Debe ser una función pura: debe resolver todo lo que se le pide sin necesidad de usar otras funciones. No debe de generar efectos secundarios ni usar funciones como localStorage o sessionStorage. No debe de requerir más que una acción que puede tener un argumento.
3. Inmutabilidad de datos: debe retornar un estado nuevo.
4. Usualmente recibe solo dos argumentos: el valor inicial y la acción a ejecutar.

Procedimiento de uso de un reducer y su hook useReducer
-------------------------------------------------------

1. Definir el estado inicial (usualmente es un arreglo vacío) y una función de inicialización.
2. Definir el reducer. El reducer es una función que usa dos argumentos: una variable de estado (que es el que almacena los cambios de estado) y una acción, la cual es un objeto que genera el valor para el próximo estado según las propiedades definidas en dicho objeto.
3. Emplear el hook useReducer, el cual recibirá como parámetros el reducer y el estado inicial (en ese orden). El resultado es un arreglo de dos elementos: una lista de elementos con los estados cambiados y una función de despacho (dispatch).
4. Desestructurar el arreglo en una variable con los elementos de estados cambiados y el dispatch.

Cambio de estado con la acción despachadora (dispatch)
------------------------------------------------------
1. Establecer un nuevo estado con la misma figura que el estado inicial.
2. Se genera un nuevo objeto de acción que recibe como propiedades el tipo de acción y el nuevo estado definido en el paso anterior.
3. Se despacha el cambio usando la acción definida en el paso previo.

Ejemplo:

todoReducer.js: (reducer)

/**
 * Paso 2 del Procedimiento de uso de un reducer y su hook useReducer
 */

export const todoReducer = (state = [], action) => {
  switch (action.type) {
    case 'add':
      return [...state, action.payload];

    default:
      return state;
  }
};

TodoApp.js:

import React, { useReducer } from "react";
import "./styles.css";
import { todoReducer } from "./todoReducer";
/**
   * Paso 1 del Procedimiento de uso de un reducer y su hook useReducer
   */
const init = () => {
    return [
        {
          id: new Date().getTime(),
          desc: "Aprender React",
          done: false,
        },
      ];
}

export const TodoApp = () => {
  
  /**
   * Pasos 3 al 4 del Procedimiento de uso de un reducer y su hook useReducer
   */
  const [todos, dispatch] = useReducer(todoReducer, [], init); // el arreglo vacío es del paso 1 del Procedimiento de uso de un reducer y su hook useReducer

  const handleAddTodo = (e) => {
    e.preventDefault();
    
    /**
     * Cambio de estado con los pasos del 1 al 3
     */
    const newTodo = {
        id: new Date().getTime(),
        desc: "Nueva tarea",
        done: false,
      }
    const action = {
        type: 'add',
        payload: newTodo,
    }
    dispatch(action);
    
  }

  return (
    ...
  );
};

Notar que la acción es siempre un objeto con dos propiedades: tipo y payload:

const action = {
    type: 'tipo',
	payload: <objeto de cambio de estado>,
}


Manejo de contextos y su hook useContext
========================================

Contexto: se define contexto por el elemento que permite comunicar datos entre componentes sin depender secuencialmente un componente de otro, que normalmente se da a través de los props.

Procedimiento:

1. Crear el contexto. Ejemplo:

UserContext.js:

import { createContext } from "react";

/**
 * Se crea una variable de contexto con la funcion createContext
 */
export const UserContext = createContext(null);

2. Usar el componente del contexto en la aplicación. Este contexto recibirá un valor que será aprovechado por los componentes hijos.
Ejemplo:

MainApp.js:

import React, { useState } from "react";
import { AppRouter } from "./AppRouter";
import { UserContext } from "./UserContext";

export const MainApp = () => {
  
  // valor y funcion que seran propagados en el contexto
  const [user, setUser] = useState({})
  
  return (
    /* 
      Invoco el componente UserContext en calidad de proveedor (Provider).
      Paso un valor que sera propagado y aprovechado por los componentes hijos.
     */
    <UserContext.Provider value={ {
      user,
      setUser,
    } }>
      <AppRouter />
    </UserContext.Provider>
  );
};

3. Cualquier componente hijo puede aprovechar el contexto previamente creado. Ejemplo:

AppRouter.js (padre de los demás componentes que están enrutados):

import React from "react";
import {
  BrowserRouter as Router,
  Switch,
  Route,
  Redirect,
} from "react-router-dom";
import { AboutScreen } from "./AboutScreen";
import { LoginScreen } from "./LoginScreen";
import { HomeScreen } from "./HomeScreen";
import { NavBar } from "./NavBar";

export const AppRouter = () => {
  return (
    <div>
      <Router>
        <div>
          <NavBar />
          <Switch>
            <Route exact path="/" component={HomeScreen} />
            <Route exact path="/login" component={LoginScreen} />
            <Route exact path="/about" component={AboutScreen} />
            <Redirect to="/" />
          </Switch>
        </div>
      </Router>
    </div>
  );
};

HomeScreen.js: (componente que aprovecha el contexto creado)

import React, { useContext } from "react";
import { UserContext } from "./UserContext";

export const HomeScreen = () => {
  /**
   * useContext: hook que aprovecha el contexto creado previamente.
   * En este caso, declaramos una variable userContext que tendra, como
   * contexto, la clase UserContext
   */
  const {user} = useContext(UserContext);
  console.log(user);
  return (
    <div>
      <h1>HomeScreen</h1>
      <hr />
      <pre>
        {JSON.stringify(user, null, 3)}
      </pre>
    </div>
  );
};

LoginScreen.js:

import React, { useContext } from "react";
import { UserContext } from "./UserContext";

export const LoginScreen = () => {
  /**
   * A diferencia del HomeScreen, obtengo el setUser y lo paso como
   * callback para el evento onClick del boton.
   */
  const { setUser } = useContext(UserContext);
  
  return (
    <div>
      <h1>LoginScreen</h1>
      <hr />
      <button
        className="btn btn-dark"
        onClick={() => setUser({ id: 1234, name: "Tino" })}
      >
        Login
      </button>
    </div>
  );
};

AboutScreen.js:

import React, { useContext } from "react";
import { UserContext } from "./UserContext";

export const AboutScreen = () => {
  /**
   * Se procede de forma similar a la ventana de LoginScreen, pero con la funcionalidad
   * del Logout para cambiar el objeto empleando el mismo contexto.
   */
  const {user, setUser} = useContext(UserContext);

  const handleClick = () => {
    setUser({});
  }
  return (
    <div>
      <h1>AboutScreen</h1>
      <hr />
      <pre> {JSON.stringify(user, null, 3)} </pre>
      <button className="btn btn-outline-dark" onClick={handleClick}>Logout</button>
    </div>
  );
};

Manejo dinámico de imágenes
===========================

Se emplea la función del contexto de Webpack de la siguiente forma:

1. Importar las imágenes y guardarlas en una variable:

const heroImages = require.context("../../assets/heroes", true);

Nota: se puede guardar esta línea o similar en otro archivo, exportarla e importarla desde un componente.

2. Establecer la ruta de la imagen con texto dinámico:

const imagePath = heroImages(`./${heroId}.jpg`);

3. Emplear la ruta generada en la propiedad src del elemento de imagen:

<img className="img-thumbnail" src={imagePath} alt={id} />

Ejemplo:

HeroScreen.js:
import React, { useMemo } from "react";
import { useParams, Navigate, useNavigate } from "react-router-dom";
import getHeroById from "../../selectors/getHeroById";

/**
 * Importo imagenes desde ruta dinamica:
 */
const heroImages = require.context("../../assets/heroes", true);

export const HeroScreen = () => {
  const { heroId } = useParams();

  /**
   * uso concreto de useMemo: debo llamarla una sola vez y mantener el retorno de dicha
   * llamada de manera permanente hasta que haya un cambio en la condicion (el segundo parametro)
   */
  const hero = useMemo(() => getHeroById(heroId), [heroId]);

  const navigate = useNavigate();

  if (!hero) {
    return <Navigate to="/" />;
  }

  const { id, superhero, publisher, alter_ego, first_appearance, characters } =
    hero;

  // obtengo la ruta dinamica de la imagen y lo paso por parametro
  const imagePath = heroImages(`./${heroId}.jpg`);

  const handleReturn = () => {
    navigate(-1);
  };

  return (
    <div className="row animate__animated animate__fadeIn">
      <h1>{superhero}</h1>
      <hr />
      <div className="col animate__animated animate__fadeIn">
        <img className="img-thumbnail" src={imagePath} alt={id} />
      </div>
      <div className="col animate__animated animate__fadeIn">
        <p className="lead"> Publisher: {publisher} </p>
        <p className="lead"> Alter ego: {alter_ego} </p>
        <p className="lead"> Characters: {characters} </p>
        <p className="lead"> First appearance: {first_appearance} </p>
        <button type="button" className="btn btn-dark" onClick={handleReturn}>
          Back to list
        </button>
      </div>
    </div>
  );
};



Uso de rutas a través de React Router
=====================================

Para la generación de rutas y hacer que la página funcione como un SPA, es necesario usar la librería React Router.

Para instalar React Router, ingresar:

npm install react-router-dom

Aquí un ejemplo de cómo configurar el Router de React (v6):

App.js:
import { BrowserRouter as Router, Routes, Route } from "react-router-dom"; // React Router

// componentes
import Navigation from "./components/Navigation";
import Footer from "./components/Footer";

// paginas
import Home from "./pages/Home";
import About from "./pages/About";
import NotFound from "./pages/NotFound";

function App() {
  return (
    <>
      <Router>
        <Navigation />
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
        <Footer />
      </Router>
    </>
  );
}

export default App;

Y una configuración de enlaces en Footer:

Footer.js:

import React from "react";
import { Link } from "react-router-dom";

export default function Footer() {
  return (
    <div className="container-fluid bg-dark border-bottom">
      <div className="container">
        <div className="row">
          <div className="col">
            <ul className="list-unstyled">
              <li className="list-unstyled-item">
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/"
                >
                  Home
                </Link>
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/tino"
                >
                  Tino
                </Link>
              </li>
              <li className="list-unstyled-item">
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/cv"
                >
                  CV
                </Link>
              </li>
              <li className="list-unstyled-item">
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/portafolio"
                >
                  <FormattedMessage
                    id="menu.portfolio"
                    defaultMessage="Portafolio"
                  />
                </Link>
              </li>
              <li className="list-unstyled-item">
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/contacto"
                >
                  <FormattedMessage
                    id="menu.contact"
                    defaultMessage="Contacto"
                  />
                </Link>
              </li>
            </ul>
          </div>
      </div>
    </div>
  );
}

Es posible notar dos cosas:

1. Los elementos y rutas de navegación funcionan dentro del contexto de Router. Esto es, si se desarrollan un panel de navegación y un footer, los enlaces funcionan dentro del bloque Router.
2. Link reemplaza al objeto <a> del HTML con todas las propiedades típicas de un enlace. Nuevamente, esto funciona solo dentro del contexto de Router. El beneficio de Link es que hace que los enlaces sean persistentes y no obliguen al sitio a refrescarse totalmente, cumpliendo la funcionalidad de una SPA.

También existe un elemento NavLink, el cual funciona como Link pero tiene, en adición, las propiedades de ruta exacta y la clase que determina que el link activo actual. Ejemplo:

NavBar.jsx:

import { useContext } from "react";
import { Link, NavLink, useNavigate } from "react-router-dom";
import { AuthContext } from "../../auth/context/AuthContext";

export const Navbar = () => {

  const navigate = useNavigate();

  const context  = useContext(AuthContext);
  const {logged, user, logout} = context;

  //console.log(context)

  const handleLogout = () => {
    if(!logged) return;
    logout();
    navigate('/login', { replace: true });
  }

  return (
    <nav className="navbar navbar-expand-sm navbar-dark bg-dark p-2 sticky-top">
      <Link className="navbar-brand" to="/">
        HeroesSPA
      </Link>
      <div className="navbar-collapse">
        <div className="navbar-nav">
          <NavLink
            className={({ isActive }) =>
              `nav-item nav-link ${isActive ? "active" : ""}`
            }
            to="/marvel"
          >
            Marvel
          </NavLink>
          <NavLink
            className={({ isActive }) =>
              `nav-item nav-link ${isActive ? "active" : ""}`
            }
            to="/dc"
          >
            DC
          </NavLink>
          <NavLink
            className={({ isActive }) =>
              `nav-item nav-link ${isActive ? "active" : ""}`
            }
            to="/search"
          >
            Search
          </NavLink>
        </div>
      </div>
      <div className="navbar-collapse collapse w-100 order-3 dual-collapse2 d-flex justify-content-end">
        <ul className="navbar-nav ml-auto">
          <span className="nav-item nav-link text-info">{user?.name}</span>
          <button onClick={handleLogout} className="nav-item nav-link btn">Logout</button>
        </ul>
      </div>
    </nav>
  );
};

Construcción de más un router
-----------------------------

Sea el siguiente flujo:

Login --> Pantalla de control

Se podrían definir los siguientes componentes:

HeroesApp.jsx (principal):

import React from 'react'
import { AuthProvider } from './auth/context/AuthContext'
import { AppRouter } from './router'

export const HeroesApp = () => {
  return (
    <AuthProvider>
      <AppRouter />
    </AuthProvider>
  )
}

AppRouter.jsx (ruteador padre):

import React from "react";
import { Navigate, Route, Routes } from "react-router-dom";
import { LoginPage } from "../auth";
import { DcPage, HeroesRoutes, MarvelPage } from "../heroes";
import { Navbar } from "../ui";
import { PrivateRoute } from "./PrivateRoute";
import { PublicRoute } from "./PublicRoute";

export const AppRouter = () => {
  return (
    <>
      <Routes>
        <Route
          path="/*"
          element={
            <PrivateRoute>
              <HeroesRoutes />
            </PrivateRoute>
          }
        />
        <Route
          path="login/*"
          element={
            <PublicRoute>
              <Routes>
                <Route path="/*" element={<LoginPage />} />
              </Routes>
            </PublicRoute>
          }
        />
      </Routes>
    </>
  );
};


Acceder a Login:

LoginPage.jsx:

import React, { useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../context/AuthContext';

export const LoginPage = () => {

  const {login} = useContext(AuthContext)

  const navigate = useNavigate();

  const handleLogin = () => {
    
    // recordar última página visitada
    const lastPath = localStorage.getItem('lastPath') || '/';

    login('Tino');
    navigate(lastPath, { replace: true }); // evita que tenga efecto del botón "atrás" del navegador
  }


  return (
    <div className='container mt-5'>
      <h1>Login</h1>
      <hr/>
      <button onClick={handleLogin} className='btn btn-primary'>Login</button>
    </div>
  )
}



El contexto empleado determina el acceso a las rutas esperadas.

useNavigate y useLocation
-------------------------

Son hooks del paquete de React Router.

useNavigate: permite ir hacia el sitio a ser redirigido. Ejemplo:

function Redirect() {
  let navigate = useNavigate();
  function handleClick() {
    navigate('/home')
  }
  return (
    <div>
      <button onClick={handleClick}>go home</button>
    </div>
  );
}

El argumento de navigate puede también conducirnos a la próxima página anterior o posterior:
navigate(-1):  página anterior.
navigate(1): página posterior.

useLocation: obtiene un objeto con los valores de la ubicación actual.

const location = useLocation();

El contenido de location puede ser el que sigue:

{
  key: 'ac3df4', // not with HashHistory!
  pathname: '/somewhere',
  search: '?some=search-string',
  hash: '#howdy',
  state: {
    [userDefined]: true
  }
}

Ambos hooks pueden combinar bien para una búsqueda por formulario.

SearchPage.jsx:

import React from "react";
import { useLocation, useNavigate } from "react-router-dom";
import { useForm } from "../../hooks/useForm";
import queryString from 'query-string';
import { getHeroesByName } from "../helpers/getHeroesByName";
import { HeroCard } from "../components/HeroCard";

export const SearchPage = () => {

  const navigate = useNavigate();
  const location = useLocation();
  const query = queryString.parse(location.search);
  const {q = ''} = query;

  const heroes = getHeroesByName(q);

  const { searchText, onInputChange } = useForm({
    searchText: q,
  });

  const onSearchSubmit = (e) => {
    e.preventDefault();
    if(searchText.trim().length <= 1) return;
    navigate(`?q=${searchText}`);
  }

  return (
    <>
      <h1>Search</h1>
      <hr />
      <div className="row">
        <div className="col-5">
          <h4>Enter text to search</h4>
          <hr />
          <form onSubmit={onSearchSubmit}>
            <input
              type="text"
              name="searchText"
              value={searchText}
              className="form-control"
              placeholder="Enter text"
              onChange={onInputChange}
              autoComplete="off"
            />
            <button className="btn btn-dark mt-2">Search</button>
          </form>
        </div>
        <div className="col-7">
          <h4>Results</h4>
          <hr />
          {
            (q === '')
            ? <div className="alert alert-primary">Please search hero...</div>
            : (heroes.length === 0)
              ? <div className="alert alert-danger">No results for {q}. Try again</div>
              : <div className="alert alert-success">{heroes.length} results for {q}</div>
          }
          
          
        </div>
      </div>
      <div className="row mt-4 mb-4">
        {heroes.map(hero => (
          <HeroCard key={hero.id} {...hero} />
        ))}
      </div>
    </>
  );
};

QueryString
===========

Utilitario para trabajar en las búsquedas por término clave.

Instalación:

npm i query-string

Ejemplo en SearchPage.jsx:

  /**
   * Uso de hooks para generar la ruta de busqueda y efectuar
   * la busqueda por termino clave
   */
  const navigate = useNavigate();
  const location = useLocation();
  const query = queryString.parse(location.search);
  const {q = ''} = query;

  const heroes = getHeroesByName(q);

  const { searchText, onInputChange } = useForm({
    searchText: q,
  });

  const onSearchSubmit = (e) => {
    e.preventDefault();
    if(searchText.trim().length <= 1) return;
    navigate(`?q=${searchText}`);
  }


Enrutamiento protegido
======================

I. Definir contexto y reducer para la aplicación
------------------------------------------------

Etapa previa: crear los tipos para la acción efectuada por el reducer.
Supongamos que se quiera restringir con un login el acceso a las rutas privadas. Entonces, los dos tipos de acciones para llevar a cabo ese control serían:

types.js:

export const types = {
    login: "AUTH - login",
    logout: "AUTH - logout",
}

Usando el concepto de reducer, se podría definir una función como:

authReducer.js:

import { types } from "../types/types";

export const authReducer = (state = {}, action) => {
  switch (action.type) {
    case types.login:
      return {
        ...state,
        logged: true,
        user: action.payload,
      };
    case types.logout:
      return {
        logged: false,
      };
    default:
      return state;
  }
};


En el caso del contexto, se definiría un contexto como el que sigue:

AuthContext.jsx:

import { createContext } from "react";

export const AuthContext = createContext();

Crear, asimismo, su respectivo provider:


// provider
const initialState = { logged: false };

const init = () => {
  const user = JSON.parse(localStorage.getItem('user'));
  return {
    logged: !!user,
    user: user,
  }
}

export const AuthProvider = ({ children }) => {
  const [authState, dispatch] = useReducer(authReducer, initialState, init);

  const login = (name = '') => {
    const user = {id: '123', name: name}
    const action = {
      type: types.login,
      payload: user,
    }
    localStorage.setItem('user', JSON.stringify(user));
    dispatch(action);
  }

  const logout = () => {
    localStorage.removeItem('user');
    const action = {type: types.logout}
    dispatch(action);
  }

  return (
    <AuthContext.Provider value={{
      ...authState,
      login: login,
      logout: logout,
    }}>
        {children}
    </AuthContext.Provider>
  );
};


II. Emplear el contexto creado previamente
------------------------------------------

El mismo debe afectar al punto más alto de la aplicación, esto es, un high-order component.

Ejemplo:

import React from 'react'
import { AuthProvider } from './auth/context/AuthContext'
import { AppRouter } from './router'

export const HeroesApp = () => {
  return (
    <AuthProvider>
      <AppRouter />
    </AuthProvider>
  )
}


El contexto debe propagar al resto de la aplicación al objeto value, dado que contiene a los elementos obtenidos a partir del reducer: el usuario logueado y el despachador (dispatch) de acciones que afectarán el estado de la sesión y las rutas a las que se tendrá acceso.

III. Separar el ruteo público del privado
-----------------------------------------

En HeroesApp.js se observa que:

    <AuthProvider>
      <AppRouter />
    </AuthProvider>

el prop value pasa el objeto conformado por el usuario y el despachador al resto de la aplicación. El próximo componente es el AppRouter, el cual alberga dos conjuntos de rutas:

Públicas: en este caso, sólo está la pantalla de login.
Privadas: las rutas de la aplicación.

En concreto, quedaría:

AppRouter.jsx:

import React from "react";
import { Navigate, Route, Routes } from "react-router-dom";
import { LoginPage } from "../auth";
import { DcPage, HeroesRoutes, MarvelPage } from "../heroes";
import { Navbar } from "../ui";
import { PrivateRoute } from "./PrivateRoute";
import { PublicRoute } from "./PublicRoute";

export const AppRouter = () => {
  return (
    <>
      <Routes>
        <Route
          path="/*"
          element={
            <PrivateRoute>
              <HeroesRoutes />
            </PrivateRoute>
          }
        />
        <Route
          path="login/*"
          element={
            <PublicRoute>
              <Routes>
                <Route path="/*" element={<LoginPage />} />
              </Routes>
            </PublicRoute>
          }
        />
      </Routes>
    </>
  );
};



IV. Proteger las rutas privadas con login e implementar el logout
-----------------------------------------------------------------

Considerar LoginPage.jsx:

import React, { useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../context/AuthContext';

export const LoginPage = () => {

  const {login} = useContext(AuthContext)

  const navigate = useNavigate();

  const handleLogin = () => {
    
    // recordar última página visitada
    const lastPath = localStorage.getItem('lastPath') || '/';

    login('Tino');
    navigate(lastPath, { replace: true }); // evita que tenga efecto del botón "atrás" del navegador
  }


  return (
    <div className='container mt-5'>
      <h1>Login</h1>
      <hr/>
      <button onClick={handleLogin} className='btn btn-primary'>Login</button>
    </div>
  )
}

Al aprovechar el logueo, entramos al conjunto de páginas públicas:

PrivateRoute.jsx:

import React, { useContext } from "react";
import { Navigate, useLocation } from "react-router-dom";
import { AuthContext } from "../auth/context/AuthContext";

export const PrivateRoute = ({ children }) => {
  
  const { logged } = useContext(AuthContext);

  // última página visitada
  const {pathname, search} = useLocation();
  const lastPath = pathname + search;
  localStorage.setItem('lastPath', lastPath);

  return logged ? children : <Navigate to="/login" />;
};

Si no accedemos allí, esto es si no hay login, quedamos en la zona de páginas públicas:

import React, { useContext } from "react";
import { Navigate } from "react-router-dom";
import { AuthContext } from "../auth/context/AuthContext";

export const PublicRoute = ({ children }) => {
  
  const { logged } = useContext(AuthContext);

  return !logged ? children : <Navigate to="/" />;
};


Redux para React
================

Redux: es el contenedor predecible del estado de una aplicación React.

Conceptos
---------

* Store: la "fuente única de la verdad". Es el concentrador de la información que los componentes consumirán.
* El reducer es el concepto del cual se basa Redux.
* La principal diferencia con el uso de reducers es que estos son controlados por uno o más middlewares. El paso por el middleware dependerá de la tarea (dispatch) que se ha de generar según la acción y la naturaleza de la misma según la respuesta: síncrona o asíncrona.
* El middleware trabajará con tareas asíncronas.

Instalación:

npm install @reduxjs/toolkit react-redux

Construcción del Redux
----------------------

1. Crear dos archivos: uno del store y otro de los reducers:

store.js:

/**
 * La forma como el instructor llama a los reducers es diferente a la sugerida por los
 * creadores de RTK. Normalmente, esperaríamos importar:
 * 
 * import authReducer from '../slices/auth/authSlices'
 * 
 * Y después invocarlo como:
 * 
 * auth: authReducer
 * 
 * La forma presentada aquí es más comprensible y trabaja de la forma esperada.
 */

import { configureStore } from '@reduxjs/toolkit'
import { authSlice } from '../slices/auth/authSlice' // estilo Fernando Herrera
import { journalSlice } from '../slices/journal/journalSlice'

export const store = configureStore({
    reducer: {
      auth: authSlice.reducer, // estilo Fernando Herrera
      journal: journalSlice.reducer, // estilo Fernando Herrera
    },
  })


authSlice.js:

import { createSlice } from '@reduxjs/toolkit'
import { signInWithGoogle, registerWithEmailAndPassword, loginWithEmailAndPassword, logoutFirebase } from '../../../firebase/providers';
import { clearNotesLogout } from '../journal/journalSlice';

export const authSlice = createSlice({
  name: 'auth',
  initialState: {
    status: 'checking', // 'not-authenticated', 'checking', 'authenticated'
    uid: null,
    email: null,
    displayName: null,
    photoURL: null,
    errorMessage: null,
  },
  reducers: { // del action estoy sacando directamente el payload
    login: (state, {payload}) => {
      state.status = 'authenticated';
      state.uid = payload.uid;
      state.email = payload.email;
      state.displayName = payload.displayName;
      state.photoURL = payload.photoURL;
      state.errorMessage = null;
    },
    logout: (state, {payload}) => {
      state.status = 'not-authenticated';
      state.uid = null;
      state.email = null;
      state.displayName = null;
      state.photoURL = null;
      state.errorMessage = payload?.errorMessage;
    },
    checkingCredentials: (state) => {
      state.status = 'checking';
    },
  },
})

// thunks - ini

export const checkingAuthentication = (email, password) => {
  return async (dispatch) => {
    dispatch(checkingCredentials())
  }
}

export const startGoogleSignIn = () => {
  return async (dispatch) => {
    dispatch(checkingCredentials());
    const result = await signInWithGoogle();
    //console.log(result);
    if(!result.ok) return dispatch(logout(result.errorMessage));
    dispatch(login(result));
  }
}

export const startCreatingUserWithEmailPassword = ({email, password, displayName}) => {
  return async (dispatch) => {
    dispatch(checkingCredentials());

    const {ok, uid, photoURL, errorMessage} = await registerWithEmailAndPassword({email, password, displayName});
    if(!ok) return dispatch(logout({errorMessage}));
    dispatch(login( {uid, displayName, email, photoURL} ));
  }
}

export const startLoginWithEmailPassword = ({email, password}) => {
  return async (dispatch) => {
    dispatch(checkingCredentials());

    const {ok, displayName, uid, photoURL, errorMessage} = await loginWithEmailAndPassword({email, password});
    //console.log('result in slice: ', result);
    if(!ok) return dispatch(logout({errorMessage}));
    dispatch(login( {uid, displayName, email, photoURL} ));
  }
}

export const startLogout = () => {
  return async (dispatch) => {
    await logoutFirebase();
    dispatch(clearNotesLogout());
    dispatch(logout({errorMessage: 'Logged out'}));
  }
}

// thunks - fin

// Action creators are generated for each case reducer function
export const { login, logout, checkingCredentials } = authSlice.actions;

Notar que están interrelacionados y el store puede combinar más de un reducer.

2. Implementar la tienda en el app principal:

main.jsx:

import React from 'react'
import ReactDOM from 'react-dom/client'
import JournalApp from './JournalApp'
import './styles.css'
import { Provider } from 'react-redux'
import { store } from './redux/store/store'

ReactDOM.createRoot(document.getElementById('root')).render(
  <Provider store={store}>
    <JournalApp />
  </Provider>
  
)

Esto es a través de Provider del react-redux.

3. Trabajar con el store configurado en cualquier punto de la aplicación que se requiera:

Obtener acceso actual a través de useSelector:
Ej.:

const {
    active: note,
    messageSaved,
    isSaving,
  } = useSelector((state) => state.journal);

Invocar un reducer para despacharlo (dispatch):
Ej.:

const dispatch = useDispatch();

useEffect(() => {
	dispatch(setActiveNote(formState));
}, [formState]);

const handleSave = () => {
	dispatch(startSavingNote());
};


Esto último es lo que produce los cambios de estado requeridos.


React + auth0
=============

auth0
-----

Escoger: Applications -> Create application -> Single Page Application

Luego, escoger React e ir a Settings.

En Settings:

Application URIs:
- Allowed Callback URLs: http://localhost:3000/
- Allowed Logout URLs: http://localhost:3000/
- Allowed Web Origins: http://localhost:3000/

Guardar los cambios.


En React
--------

Instalar:

npm i @auth0/auth0-react

En la raíz del proyecto, crear un archivo .env con los parámetros:
REACT_APP_AUTH0_DOMAIN=<valor provisto por el app en auth0>
REACT_APP_AUTH0_CLIENT_ID=<valor provisto por el app en auth0>

En index.js:

import { Auth0Provider } from "@auth0/auth0-react";

const domain = process.env.REACT_APP_AUTH0_DOMAIN;
const clientId = process.env.REACT_APP_AUTH0_CLIENT_ID;

const navigate = useNavigate();
const onRedirectCallback = (appState) => {
  navigate(appState?.returnTo || window.location.pathname);
};

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <Auth0Provider
    domain={domain}
    clientId={clientId}
    redirectUri={window.location.origin}
    onRedirectCallback={onRedirectCallback}
  >
    <App />
  </Auth0Provider>
);

Notar que es una práctica necesaria el manejar onRedirectCallback para asegurar un buen enrutamiento junto con auth0.

Issue con auth0: corregir problema de redirección después de login permanente.

React + Firebase 9+
===================

El procedimiento es más complejo que con auth0, pero más seguro y flexible en uso.

Instalación:

npm i firebase

Configuración en Firebase
-------------------------

1. En Firebase, abrir cuenta y crear proyecto.
2. Configurarlo según el tutorial: https://www.youtube.com/watch?v=mhRbYJplmX0

El resultado es un proyecto creado, por ejemplo: react-app-cursos-tino

Configuración en React
----------------------

Se requiere una carpeta, en ella crear dos archivos: uno para configuración y otro para establecer los proveedores para sesión:

Carpeta "firebase":

config.js:

import { initializeApp } from "firebase/app";
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

const firebaseConfig = {
  apiKey: import.meta.env.VITE_APP_APIKEY,
  authDomain: import.meta.env.VITE_APP_AUTHDOMAIN,
  projectId: import.meta.env.VITE_APP_PROJECTID,
  storageBucket: import.meta.env.VITE_APP_STORAGEBUCKET,
  messagingSenderId: import.meta.env.VITE_APP_MESSAGINGSENDERID,
  appId: import.meta.env.VITE_APP_APPID
};

// Inicializar Firebase y autorizacion
const FirebaseApp = initializeApp(firebaseConfig);
const FirebaseAuth = getAuth(FirebaseApp);
const FirebaseDB = getFirestore(FirebaseApp);

export {FirebaseApp, FirebaseAuth, FirebaseDB}

providers.js:

import {
  createUserWithEmailAndPassword,
  GoogleAuthProvider,
  signInWithPopup,
  signInWithEmailAndPassword,
  updateProfile,
} from "firebase/auth";
import { FirebaseAuth } from "./config";

/**
 * - Creación de proveedores de backend (por ahora solo con Google y servicio de email)
 * - Creación de métodos que usan los proveedores definidos previamente
 */

const googleProvider = new GoogleAuthProvider();

export const signInWithGoogle = async () => {
  try {
    const result = await signInWithPopup(FirebaseAuth, googleProvider);
    const { displayName, email, photoURL, uid } = result.user;

    return {
      ok: true,
      displayName,
      email,
      photoURL,
      uid, // user info
    };
  } catch (error) {
    const errorMessage = error.message;
    console.log(errorMessage);

    return {
      ok: false,
      errorMessage,
    };
  }
};

export const registerWithEmailAndPassword = async ({
  email,
  password,
  displayName,
}) => {
  try {
    const result = await createUserWithEmailAndPassword(
      FirebaseAuth,
      email,
      password
    );
    const { uid, photoURL } = result.user;
    //console.log({uid, photoURL})
    await updateProfile(FirebaseAuth.currentUser, { displayName });

    return {
      ok: true,
      uid,
      photoURL,
      email,
      displayName, // user info
    };
  } catch (error) {
    const errorMessage = error.message;
    console.log(errorMessage);

    return {
      ok: false,
      errorMessage,
    };
  }
};

export const loginWithEmailAndPassword = async ({ email, password }) => {
  try {
    const result = await signInWithEmailAndPassword(
      FirebaseAuth,
      email,
      password
    );
    
    const { uid, photoURL, displayName } = result.user;
    
    return {
      ok: true,
      uid,
      photoURL,
      email,
      displayName, // user info
    };
  } catch (error) {
    const errorMessage = error.message;
    console.log(errorMessage);

    return {
      ok: false,
      errorMessage,
    };
  }
};

export const logoutFirebase = async () => {
  return await FirebaseAuth.signOut();
}


Usar Firebase para autenticación
--------------------------------

Aprovechando la configuración inicial:

1. Crear procesos asíncronos para establecer inicios de sesión al sistema. Si se aprovecha Redux (Toolkit), quedarían los siguientes procesos (thunks):

authSlice.js:

export const checkingAuthentication = (email, password) => {
  return async (dispatch) => {
    dispatch(checkingCredentials())
  }
}

export const startGoogleSignIn = () => {
  return async (dispatch) => {
    dispatch(checkingCredentials());
    const result = await signInWithGoogle();
    //console.log(result);
    if(!result.ok) return dispatch(logout(result.errorMessage));
    dispatch(login(result));
  }
}

export const startCreatingUserWithEmailPassword = ({email, password, displayName}) => {
  return async (dispatch) => {
    dispatch(checkingCredentials());

    const {ok, uid, photoURL, errorMessage} = await registerWithEmailAndPassword({email, password, displayName});
    if(!ok) return dispatch(logout({errorMessage}));
    dispatch(login( {uid, displayName, email, photoURL} ));
  }
}

export const startLoginWithEmailPassword = ({email, password}) => {
  return async (dispatch) => {
    dispatch(checkingCredentials());

    const {ok, displayName, uid, photoURL, errorMessage} = await loginWithEmailAndPassword({email, password});
    //console.log('result in slice: ', result);
    if(!ok) return dispatch(logout({errorMessage}));
    dispatch(login( {uid, displayName, email, photoURL} ));
  }
}

export const startLogout = () => {
  return async (dispatch) => {
    await logoutFirebase();
    dispatch(clearNotesLogout());
    dispatch(logout({errorMessage: 'Logged out'}));
  }
}

2. Para login y registro, invocar las funciones definidas previamente con dispatch (RTK):

LoginPage.jsx:

  const onSubmit = (e) => {
    e.preventDefault();
    dispatch(startLoginWithEmailPassword({ email, password }));
  };

  const onGoogleSignIn = () => {
    dispatch(startGoogleSignIn());
  };


RegisterPage.jsx:


  const onSubmit = (e) => {
    e.preventDefault();
    if (!isFormValid) return;
    setFormSubmitted(true);
    dispatch(startCreatingUserWithEmailPassword(formState));
  };



Configurar Firestore
--------------------

Usando el proyecto react-app-cursos-tino, proceder con lo siguiente:

1. En la consola, escoger Firestore Database y la opción Crear bases de datos.

2. Opciones:
- Modo producción.
- Ubicación nam5.
- Habilitar.

3. Modificar las reglas de acceso:

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if true; // cambiar false por true
    }
  }
}

Gestionar Firestore
-------------------

Del mismo modo que en el caso de la autenticación, puede aprovecharse de forma directa despachando procesos tipo thunk:

journalSlice.js:

export const startNewNote = () => {
  return async (dispatch, getState) => {
    dispatch(savingNewNote());

    const { uid } = getState().auth;

    // la nueva nota
    const newNote = {
      title: "",
      body: "",
      date: new Date().getTime(),
    };

    // crear un documento (el cual contiene diversas colecciones)
    const newDoc = doc(collection(FirebaseDB, `${uid}/journal/notes`));
    await setDoc(newDoc, newNote);

    newNote.id = newDoc.id; // crea ID de nota

    dispatch(addNewEmptyNote(newNote));
    dispatch(setActiveNote(newNote));
  };
};

export const startLoadingNotes = () => {
  return async (dispatch, getState) => {
    const { uid } = getState().auth;
    if (!uid) throw new Error("El uid es requerido");

    const notes = await loadNotes(uid);
    
    dispatch(setNotes(notes));
  };
};

export const startSavingNote = () => {
  return async (dispatch, getState) => {
    dispatch(setSaving());

    const { uid } = getState().auth;
    const { active: note } = getState().journal;

    const noteToFirestore = { ...note };
    delete noteToFirestore.id;

    const docRef = doc(FirebaseDB, `${uid}/journal/notes/${note.id}`);
    await setDoc(docRef, noteToFirestore, { merge: true });

    dispatch(updateNote(note));
  };
};

export const startUploadingFiles = (files = []) => {
  return async (dispatch) => {
    dispatch(setSaving());

    // carga simultánea de archivos por promesas
    const fileUploadPromises = [];
    for (const file of files) {
      fileUploadPromises.push(fileUpload(file));
    }
    const photoUrls = await Promise.all(fileUploadPromises);

    dispatch(setPhotosToActiveNote(photoUrls));
  };
};

export const startDeletingNote = () => {
  return async (dispatch, getState) => {
    const {uid} = getState().auth;
    const {active: note} = getState().journal;

    const docRef = doc(FirebaseDB, `${uid}/journal/notes/${note.id}`);
    await deleteDoc(docRef);

    dispatch(deleteNoteById(note.id));
  }
}

Y también puede invocarse en los eventos requeridos para el CRUD sobre Firestore:

NoteView.jsx:

  const handleSave = () => {
    dispatch(startSavingNote());
  };

  const onFileInputChange = ({ target }) => {
    if (target.files === 0) return;
    console.log("subiendo archivos...");
    dispatch(startUploadingFiles(target.files));
  };

  const onDelete = () => {
    dispatch(startDeletingNote());
  }







