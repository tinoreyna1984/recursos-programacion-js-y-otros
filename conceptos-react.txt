Conceptos clave y distintivos de React JS
=========================================

Componente
----------

Es todo objeto que se visualiza en la aplicación web. Ejemplo:

import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className="App">
      <h1>Hola mundo</h1>
    </div>
  );
}

export default App;

Al crear un proyecto React JS, por defecto crea el componente principal App.js. Si se desea crear un componente principal alternativo, se crearía un archivo de JavaScript y se definiría como sigue:

import logo from './logo.svg';
import './App.css';

function MiComponente() {
  return (
    <div className="App">
      <h1>Hola mundo</h1>
    </div>
  );
}

export default MiComponente;

Renderización del componente principal
--------------------------------------

import React from "react";
import { createRoot } from "react-dom/client"; // ahora se exige en React 18
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

/**
 * Notar que ya no se invoca a la clase ReactDOM ni al metodo render
 * como tradicionalmente se hacía hasta la version 17.
 */
const root = createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

Siguiendo el ejemplo anterior, el componente principal creado, al renderizarse, podría ser MiComponente, el cual podría aparecer de la siguiente forma:

const root = createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <MiComponente />
  </React.StrictMode>
);


Propiedades o "props"
---------------------

Es el concepto clave de React. Los props son, simplemente, las propiedades de un componente hecho en React JS, del mismo modo que conocemos los tags de un bloque HTML como, por ejemplo, el de imagen:

<img src=".png" alt="" border="0" align="left" width="" height="" />

En términos de JSX, img sería un componente y los tags src, alt, border, align, width y height serían los props.

Si, por ejemplo, tenemos un componente llamado Persona en JSX (en App.js o donde se llame al componente):

<Persona nombre="Tino" edad=37 />

Los props serían nombre y edad. En la definición de componente sería:

export function Persona(){
	
	return(
		<>
			Nombre: {this.props.nombre} <br/>
			Edad: {this.props.edad}
		</>
	);
	
}

o, más típicamente:

export function Persona(props){
	
	return(
		<>
			Nombre: {props.nombre} <br/>
			Edad: {props.edad}
		</>
	);
	
}

Pueden tener valores por defecto a través de la creación del objeto defaultProps:

Persona.defaultProps = {
	nombre : "Usuario",
	edad : 25,
}

Los props pueden también recibirse como objeto:

Sea:

const persona = {
nombre: "Tino",
edad: 37,
correo: 'tinoreyna1984@gmail.com'
};

Pasamos persona a un componente como este (en App.js o donde se llame al componente):

<Persona persona={persona} />

El componente leerá la persona de la siguiente forma:

export function Persona(props){
	return(
		<>
			Nombre: {props.persona.nombre} <br/>
			Edad: {props.persona.edad} <br/>
			Correo: {props.persona.correo} 
		</>
	);
}

o:

export function Persona(props){

	// la forma más limpia: desestructurando objetos
	{persona} = props;
	{nombre, edad, correo} = persona;
	
	return(
		<>
			Nombre: {nombre} <br/>
			Edad: {edad} <br/>
			Correo: {correo} 
		</>
	);
}

Los props también pueden incluir funciones:

Sea la función declarada en App.js o en otro componente:

const saludoFn = (nombre) => {
	alert("Hola, " + nombre);
};

Sea el componente declarado en App.js o en otro componente:

<Saludo persona={persona} saludoFn={saludoFn} />

El componente sería el siguiente:

export default function Saludo(props) {

  // Notese que las variables las he obtenido con el operador desestructuracion (llaves)

  const { saludoFn, persona } = props;
  const { nombre = 'Usuario' } = persona; // se le puede asignar tambien un valor por defecto de esta forma

  return (
    <>
      <button onClick={() => saludoFn(nombre)}>Saludar</button>
      {/* el componente genera un botón que emplea un callback, aprovechando la función procedente del props */}
    </>
  );
}

Manejo de eventos
=================

Se tocará lo más típico:

import React, { useState } from "react";
import PropTypes from "prop-types";

export default function AddCategory({setCategories}) {
  // hooks para el campo de texto
  const [inputValue, setInputValue] = useState("");

  // cada vez que cambio el valor en el campo de texto
  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };

  // cada vez que doy enter o cliquee en algun boton para enviar el dato del formulario
  const handleSubmit = (e) => {
    e.preventDefault();
    if(inputValue.trim().length > 2){
        setCategories(categories => [inputValue, ...categories]);
        setInputValue('');
    }
    
  }

  return (
    <form onSubmit={handleSubmit}>
        <input type="text" value={inputValue} onChange={handleInputChange} />
    </form>
  );
}

onChange: evento propio de cambios en campos de texto. Se invoca un callback que determine el valor mapeado en el instante en el que se introduce un nuevo valor en ese objeto.
onSubmit: es para el envío de un conjunto de valores desde formulario.
onClick: ocurre cuando se hace click en un objeto del tipo botón.

Hooks
=====

Referencias:
https://es.reactjs.org/docs/hooks-state.html
https://es.reactjs.org/docs/hooks-effect.html

Son funcionalidades que permiten cambiar dinámica y sencillamente los estados de los props.

Los más típicos son useState y useEffect, los cuales manejan estados y efectos resultantes de los estados, respectivamente.

Reglas de Hooks:

1. Solo llamar Hooks en el nivel superior. No llamar Hooks dentro de loops, condiciones o funciones anidadas.
2. Solo llamar Hooks desde componentes de función de React. No llamar Hooks desde las funciones regulares de JavaScript. (Solo hay otro lugar válido para llamar Hooks: los Hooks personalizados por el usuario).

Referencia: https://es.reactjs.org/docs/hooks-rules.html

useState
--------

Ejemplo:

import React, { useState } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
       Click me
      </button>
    </div>
  );
}

Línea 1: Importamos el Hook useState desde React que nos permite mantener un estado local en un componente de función.

Línea 4: Dentro del componente Example declaramos una nueva variable de estado llamando al Hook useState. Este nos devuelve un par de valores, a los que damos un nombre. Llamamos count a nuestra variable porque guarda el número de clicks en el botón. La inicializamos a cero pasando 0 como único argumento a useState. El segundo elemento retornado es una función que nos permite actualizar count, por lo que le llamamos setCount.

Línea 9: Cuando el usuario hace click, llamamos a setCount con un nuevo valor. React actualizará entonces el componente Example pasándole el nuevo valor de count.

La logica del useState puede ser definida como la siguiente función:

const useState = (valor) => {
    return [valor, (valor) => {function(valor)}];
}

Para el ejemplo anterior:

/* eslint-disable react-hooks/rules-of-hooks */
import React from 'react';

function Example() {
  const useState = (count) => {
    return [count, (count) => setCount(count)];
  }

  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
       Click me
      </button>
    </div>
  );
}

useEffect
---------

import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // De forma similar a componentDidMount y componentDidUpdate
  useEffect(() => {
    // Actualiza el título del documento usando la API del navegador
    document.title = `Hiciste clic ${count} veces`;
  }, [count]); // count es la única condición que permite la ejecución del hook

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

El useEffect nos permite ejecutar un efecto secundario cuando algo sucede en el componente.

Este fragmento está basado en el ejemplo de contador de la página anterior, pero le hemos añadido una funcionalidad nueva: actualizamos el título del documento con un mensaje personalizado que incluye el número de clicks.

El useEffect nos permite ejecutar una instrucción de forma condicionada. El primer argumento es lo que se desea presentar en el renderizado y el segundo argumento es la lista de condiciones por las cuales se permite la ejecución.

useRef
------

Usa el concepto de referencia de un componente, esto es, el atributo ref de un objeto HTML. Se emplea una variable para inicializar con el hook useRef y aprovecharla ante un evento asociado al objeto en cuestión.

Ejemplo:

import React, { useRef } from "react";
import "./effects.css";

export const FocusScreen = () => {
  /**
   * useRef permite almacenar el valor del elemento de foco en una variable
   */
  const inputRef = useRef();
  const handleClick = () => {
    inputRef.current.select();
  };

  return (
    <div>
      <h1>FocusScreen</h1>
      <hr />
      <input
        ref={inputRef}
        className="form-control"
        placeholder="escribe tu nombre"
      />
      <button className="btn btn-outline-primary mt-5" onClick={handleClick}>
        Focus
      </button>
    </div>
  );
};

useLayoutEffect
---------------

Funciona como el useEffect, pero el efecto generado ocurre después de todas las mutaciones en el DOM.
La sintaxis es similar al useEffect.

useMemo
-------

Permite almacenar el valor de la ejecución de un proceso, el cual ocurre de manera controlada.
El nombre del hook viene a que este memoriza ese proceso para optimizar el desempeño del app (evita posibles llamadas recurrentes a cambios de estado que obliguen a renderizar varias veces el componente).

Ejemplo:

import React, { useMemo, useState } from "react";
import "./effects.css";
import { useCounter } from "../../hooks/useCounter";
import { procesoPesado } from "../../helpers/procesoPesado";

export const MemoHook = () => {
  const { counter, increment } = useCounter(5000);
  const [show, setShow] = useState(true);

  /**
   * useMemo: hook que permite devolver un valor memorizado a partir de un proceso
   * y un conjunto de condiciones que lo controlan
   */
  const memoProcesoPesado = useMemo(() => procesoPesado(counter), [counter]);

  return (
    <div>
        <h1>MemoHook</h1>
      <h3>
        Counter: <small>{counter}</small>
      </h3>
      <hr />
      <p>{memoProcesoPesado}</p>
      <button className="btn btn-primary" onClick={increment}>
        +1
      </button>
      <button
        className="btn btn-outline-primary ml-3"
        onClick={() => setShow(!show)}
      >
        Show/hide {JSON.stringify(show)}
      </button>
    </div>
  );
};

useCallback
-----------

Devuelve un callback memorizado.
Ejemplo:

ShowIncrement.js:

import React from "react";

export const ShowIncrement = React.memo(({ increment }) => {
  console.log("Me volví a generar.");
  return (
    <button
      className="btn btn-outline-primary"
      onClick={() => {
        increment(5);
      }}
    >
      Incrementar
    </button>
  );
});

CallbackHook.js:

import React, { useCallback, useState } from "react";
import "./effects.css";
import { ShowIncrement } from "./ShowIncrement";

export const CallbackHook = () => {
  const [counter, setCounter] = useState(10);

  /* const increment = () => {
    setCounter(counter + 1);
  }; */

  /**
   * useCallback: devuelve un callback memorizado
   */
  const increment = useCallback(
    (num) => {
        setCounter((c) => c + num);
    },
    [setCounter],
  )
  

  return (
    <div>
      <h1>useCallbackHook: {counter}</h1>
      <hr />
      <ShowIncrement increment={increment} />
    </div>
  );
};


React.memo
==========

Optimiza el renderizado de un componente con los mismos valores de props ingresados.
Ejemplo:

Small.js:

import React from 'react';

export const Small = React.memo(({value}) => {
  console.log("Me volvi a llamar");
  return (
    <small>{value}</small>
  )
});

Memorize.js: (llama al componente memorizado Small)

import React, { useState } from "react";
import "./effects.css";
import { useCounter } from "../../hooks/useCounter";
import {Small} from "./Small";

export const Memorize = () => {
  const { counter, increment } = useCounter(10);
  const [show, setShow] = useState(true);

  return (
    <div>
      <h1>
        Counter: <Small value={counter} />{" "}
      </h1>
      <hr />
      <button className="btn btn-primary" onClick={increment}>
        +1
      </button>
      <button
        className="btn btn-outline-primary ml-3"
        onClick={() => setShow(!show)}
      >
        Show/hide {JSON.stringify(show)}
      </button>
    </div>
  );
};

Reducers: definición y uso del hook useReducer
==============================================

Un reducer:
1. Es una función corriente que no puede ser asíncrona.
2. Debe ser una función pura: debe resolver todo lo que se le pide sin necesidad de usar otras funciones. No debe de generar efectos secundarios ni usar funciones como localStorage o sessionStorage. No debe de requerir más que una acción que puede tener un argumento.
3. Inmutabilidad de datos: debe retornar un estado nuevo.
4. Usualmente recibe solo dos argumentos: el valor inicial y la acción a ejecutar.

Procedimiento de uso de un reducer y su hook useReducer
-------------------------------------------------------

1. Definir el estado inicial (usualmente es un arreglo vacío) y una función de inicialización.
2. Definir el reducer. El reducer es una función que usa dos argumentos: una variable de estado (que es el que almacena los cambios de estado) y una acción, la cual es un objeto que genera el valor para el próximo estado según las propiedades definidas en dicho objeto.
3. Emplear el hook useReducer, el cual recibirá como parámetros el reducer y el estado inicial (en ese orden). El resultado es un arreglo de dos elementos: una lista de elementos con los estados cambiados y una función de despacho (dispatch).
4. Desestructurar el arreglo en una variable con los elementos de estados cambiados y el dispatch.

Cambio de estado con la acción despachadora (dispatch)
------------------------------------------------------
1. Establecer un nuevo estado con la misma figura que el estado inicial.
2. Se genera un nuevo objeto de acción que recibe como propiedades el tipo de acción y el nuevo estado definido en el paso anterior.
3. Se despacha el cambio usando la acción definida en el paso previo.

Ejemplo:

todoReducer.js: (reducer)

/**
 * Paso 2 del Procedimiento de uso de un reducer y su hook useReducer
 */

export const todoReducer = (state = [], action) => {
  switch (action.type) {
    case 'add':
      return [...state, action.payload];

    default:
      return state;
  }
};

TodoApp.js:

import React, { useReducer } from "react";
import "./styles.css";
import { todoReducer } from "./todoReducer";
/**
   * Paso 1 del Procedimiento de uso de un reducer y su hook useReducer
   */
const init = () => {
    return [
        {
          id: new Date().getTime(),
          desc: "Aprender React",
          done: false,
        },
      ];
}

export const TodoApp = () => {
  
  /**
   * Pasos 3 al 4 del Procedimiento de uso de un reducer y su hook useReducer
   */
  const [todos, dispatch] = useReducer(todoReducer, [], init); // el arreglo vacío es del paso 1 del Procedimiento de uso de un reducer y su hook useReducer

  const handleAddTodo = (e) => {
    e.preventDefault();
    
    /**
     * Cambio de estado con los pasos del 1 al 3
     */
    const newTodo = {
        id: new Date().getTime(),
        desc: "Nueva tarea",
        done: false,
      }
    const action = {
        type: 'add',
        payload: newTodo,
    }
    dispatch(action);
    
  }

  return (
    ...
  );
};

Notar que la acción es siempre un objeto con dos propiedades: tipo y payload:

const action = {
    type: 'tipo',
	payload: <objeto de cambio de estado>,
}


Manejo de contextos y su hook useContext
========================================

Contexto: se define contexto por el elemento que permite comunicar datos entre componentes sin depender secuencialmente un componente de otro, que normalmente se da a través de los props.

Procedimiento:

1. Crear el contexto. Ejemplo:

UserContext.js:

import { createContext } from "react";

/**
 * Se crea una variable de contexto con la funcion createContext
 */
export const UserContext = createContext(null);

2. Usar el componente del contexto en la aplicación. Este contexto recibirá un valor que será aprovechado por los componentes hijos.
Ejemplo:

MainApp.js:

import React, { useState } from "react";
import { AppRouter } from "./AppRouter";
import { UserContext } from "./UserContext";

export const MainApp = () => {
  
  // valor y funcion que seran propagados en el contexto
  const [user, setUser] = useState({})
  
  return (
    /* 
      Invoco el componente UserContext en calidad de proveedor (Provider).
      Paso un valor que sera propagado y aprovechado por los componentes hijos.
     */
    <UserContext.Provider value={ {
      user,
      setUser,
    } }>
      <AppRouter />
    </UserContext.Provider>
  );
};

3. Cualquier componente hijo puede aprovechar el contexto previamente creado. Ejemplo:

AppRouter.js (padre de los demás componentes que están enrutados):

import React from "react";
import {
  BrowserRouter as Router,
  Switch,
  Route,
  Redirect,
} from "react-router-dom";
import { AboutScreen } from "./AboutScreen";
import { LoginScreen } from "./LoginScreen";
import { HomeScreen } from "./HomeScreen";
import { NavBar } from "./NavBar";

export const AppRouter = () => {
  return (
    <div>
      <Router>
        <div>
          <NavBar />
          <Switch>
            <Route exact path="/" component={HomeScreen} />
            <Route exact path="/login" component={LoginScreen} />
            <Route exact path="/about" component={AboutScreen} />
            <Redirect to="/" />
          </Switch>
        </div>
      </Router>
    </div>
  );
};

HomeScreen.js: (componente que aprovecha el contexto creado)

import React, { useContext } from "react";
import { UserContext } from "./UserContext";

export const HomeScreen = () => {
  /**
   * useContext: hook que aprovecha el contexto creado previamente.
   * En este caso, declaramos una variable userContext que tendra, como
   * contexto, la clase UserContext
   */
  const {user} = useContext(UserContext);
  console.log(user);
  return (
    <div>
      <h1>HomeScreen</h1>
      <hr />
      <pre>
        {JSON.stringify(user, null, 3)}
      </pre>
    </div>
  );
};

LoginScreen.js:

import React, { useContext } from "react";
import { UserContext } from "./UserContext";

export const LoginScreen = () => {
  /**
   * A diferencia del HomeScreen, obtengo el setUser y lo paso como
   * callback para el evento onClick del boton.
   */
  const { setUser } = useContext(UserContext);
  
  return (
    <div>
      <h1>LoginScreen</h1>
      <hr />
      <button
        className="btn btn-dark"
        onClick={() => setUser({ id: 1234, name: "Tino" })}
      >
        Login
      </button>
    </div>
  );
};

AboutScreen.js:

import React, { useContext } from "react";
import { UserContext } from "./UserContext";

export const AboutScreen = () => {
  /**
   * Se procede de forma similar a la ventana de LoginScreen, pero con la funcionalidad
   * del Logout para cambiar el objeto empleando el mismo contexto.
   */
  const {user, setUser} = useContext(UserContext);

  const handleClick = () => {
    setUser({});
  }
  return (
    <div>
      <h1>AboutScreen</h1>
      <hr />
      <pre> {JSON.stringify(user, null, 3)} </pre>
      <button className="btn btn-outline-dark" onClick={handleClick}>Logout</button>
    </div>
  );
};


Uso de rutas a través de React Router
=====================================

Para la generación de rutas y hacer que la página funcione como un SPA, es necesario usar la librería React Router.

Para instalar React Router, ingresar:

npm install react-router-dom

Aquí un ejemplo de cómo configurar el Router de React (v6):

App.js:
import { BrowserRouter as Router, Routes, Route } from "react-router-dom"; // React Router

// componentes
import Navigation from "./components/Navigation";
import Footer from "./components/Footer";

// paginas
import Home from "./pages/Home";
import About from "./pages/About";
import NotFound from "./pages/NotFound";

function App() {
  return (
    <>
      <Router>
        <Navigation />
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
        <Footer />
      </Router>
    </>
  );
}

export default App;

Y una configuración de enlaces en Footer:

Footer.js:

import React from "react";
import { Link } from "react-router-dom";

export default function Footer() {
  return (
    <div className="container-fluid bg-dark border-bottom">
      <div className="container">
        <div className="row">
          <div className="col">
            <ul className="list-unstyled">
              <li className="list-unstyled-item">
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/"
                >
                  Home
                </Link>
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/tino"
                >
                  Tino
                </Link>
              </li>
              <li className="list-unstyled-item">
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/cv"
                >
                  CV
                </Link>
              </li>
              <li className="list-unstyled-item">
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/portafolio"
                >
                  <FormattedMessage
                    id="menu.portfolio"
                    defaultMessage="Portafolio"
                  />
                </Link>
              </li>
              <li className="list-unstyled-item">
                <Link
                  className="nav-link h6"
                  aria-current="page"
                  to="/contacto"
                >
                  <FormattedMessage
                    id="menu.contact"
                    defaultMessage="Contacto"
                  />
                </Link>
              </li>
            </ul>
          </div>
      </div>
    </div>
  );
}

Es posible notar dos cosas:

1. Los elementos y rutas de navegación funcionan dentro del contexto de Router. Esto es, si se desarrollan un panel de navegación y un footer, los enlaces funcionan dentro del bloque Router.
2. Link reemplaza al objeto <a> del HTML con todas las propiedades típicas de un enlace. Nuevamente, esto funciona solo dentro del contexto de Router. El beneficio de Link es que hace que los enlaces sean persistentes y no obliguen al sitio a refrescarse totalmente, cumpliendo la funcionalidad de una SPA.

También existe un elemento NavLink, el cual funciona como Link pero tiene, en adición, las propiedades de ruta exacta y la clase que determina que el link activo actual. Ejemplo:

NavBar.js:

import React from "react";
import { Link, NavLink } from "react-router-dom";

export const NavBar = () => {
  return (
    <nav className="navbar navbar-expand-sm navbar-dark bg-dark">
      <div className="container-fluid">
        <Link className="navbar-brand" to="/">
          useContext
        </Link>
        <div className="collapse navbar-collapse" id="navbarNavAltMarkup">
          <div className="navbar-nav">
            <NavLink exact activeClassName="active" className="nav-link" aria-current="page" to="/">
              Home
            </NavLink>
            <NavLink exact activeClassName="active" className="nav-link" to="/login">
              Login
            </NavLink>
            <NavLink exact activeClassName="active" className="nav-link" to="/about">
              About
            </NavLink>
          </div>
        </div>
      </div>
    </nav>
  );
};

NOTA: en la v6, ya no es necesaria la palabra exact, ni establecer el atributo activeClassName. En su lugar, el enlace activo se renderiza según la lógica que condiciona la variable className:

className={ ({isActive}) => "nav-item nav-link " + (isActive ? "active" : "") }

Construcción de más un router
-----------------------------

Sea el siguiente flujo:

Login --> Pantalla de control

Se podrían definir los siguientes componentes:

HeroesApp.js (principal):
import React from 'react'
import { AppRouter } from './routers/AppRouter'

export const HeroesApp = () => {
  return (
    <AppRouter />
  )
}

AppRouter.js (ruteador padre):

import React from "react";
import { BrowserRouter as Router, Route, Routes } from "react-router-dom";
import { LoginScreen } from "../components/login/LoginScreen";
import { DashboardRoutes } from "./DashboardRoutes";

export const AppRouter = () => {
  return (
    <Router>
      <Routes>
        <Route path="/login" element={<LoginScreen />} />
        <Route path="/*" element={<DashboardRoutes />} />
      </Routes>
    </Router>
  );
};

Acceder a Login:

LoginScreen.js:

import React from "react";
import { useNavigate } from "react-router-dom";

export const LoginScreen = () => {
  const navigate = useNavigate();

  const handleLogin = () => {
    navigate("/marvel", {
      replace: true,
    });
  };

  return (
    <div className="container">
      <h1>Login</h1>
      <hr />
      <button className="btn btn-dark" onClick={handleLogin}>
        Entrar
      </button>
    </div>
  );
};


Si tiene éxito el login, sigue el panel de control del sitio.

DashboardRoutes.js:

import React from "react";
import { Route, Routes } from "react-router-dom";
import { DcScreen } from "../components/dc/DcScreen";
import { NavBar } from "../components/ui/NavBar";
import { MarvelScreen } from "../components/marvel/MarvelScreen";
import { SearchScreen } from "../components/search/SearchScreen";
import { HeroScreen } from "../components/hero/HeroScreen";

export const DashboardRoutes = () => {
  return (
    <>
      <NavBar />
      <div className="container">
        <Routes>
          <Route path="marvel" element={<MarvelScreen />} />
          <Route path="dc" element={<DcScreen />} />
          <Route path="search" element={<SearchScreen />} />
          <Route path="hero/:heroId" element={<HeroScreen />} />
          <Route path="/" element={<MarvelScreen />} />
        </Routes>
      </div>
    </>
  );
};

El Navbar empleado aquí es:

NavBar.js:

import React from "react";
import { Link, NavLink, useNavigate } from "react-router-dom";

export const NavBar = () => {
  const navigate = useNavigate();

  const handleLogout = () => {
    navigate("/login", {
      replace: true,
    });
  };

  return (
    <nav className="navbar navbar-expand-sm navbar-dark bg-dark">
      <Link className="navbar-brand" to="/">
        HeroesApp
      </Link>

      <div className="navbar-collapse">
        <div className="navbar-nav">
          <NavLink
            className={({ isActive }) =>
              "nav-item nav-link " + (isActive ? "active" : "")
            }
            to="/marvel"
          >
            Marvel
          </NavLink>

          <NavLink
            className={({ isActive }) =>
              "nav-item nav-link " + (isActive ? "active" : "")
            }
            to="/dc"
          >
            DC
          </NavLink>

          <NavLink
            className={({ isActive }) =>
              "nav-item nav-link " + (isActive ? "active" : "")
            }
            to="/search"
          >
            Search
          </NavLink>
        </div>
      </div>

      <div className="navbar-collapse collapse w-100 order-3 dual-collapse2 d-flex justify-content-end">
        <ul className="navbar-nav ml-auto">
          <span className="nav-item nav-link text-info">Tino</span>
          <button className="nav-item nav-link btn" onClick={handleLogout}>
            Logout
          </button>
        </ul>
      </div>
    </nav>
  );
};

Si se accede al Logout, regresa a la pantalla de login.

useNavigate y useLocation
-------------------------

Son hooks del paquete de React Router.

useNavigate: permite ir hacia el sitio a ser redirigido. Ejemplo:

function Redirect() {
  let navigate = useNavigate();
  function handleClick() {
    navigate('/home')
  }
  return (
    <div>
      <button onClick={handleClick}>go home</button>
    </div>
  );
}

El argumento de navigate puede también conducirnos a la próxima página anterior o posterior:
navigate(-1):  página anterior.
navigate(1): página posterior.

useLocation: obtiene un objeto con los valores de la ubicación actual.

const location = useLocation();

El contenido de location puede ser el que sigue:

{
  key: 'ac3df4', // not with HashHistory!
  pathname: '/somewhere',
  search: '?some=search-string',
  hash: '#howdy',
  state: {
    [userDefined]: true
  }
}

Ambos hooks pueden combinar bien para una búsqueda por formulario.

SearchScreen.js:

import React, { useMemo } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import queryString from "query-string";
import { useForm } from "../../hooks/useForm";
import getHeroesByName from "../../selectors/getHeroesByName";
import { HeroCard } from "../hero/HeroCard";

export const SearchScreen = () => {
  /**
   * Uso de hooks para generar la ruta de busqueda y efectuar
   * la busqueda por termino clave
   */
  const navigate = useNavigate();
  const location = useLocation();
  const query = queryString.parse(location.search);
  const { q = "" } = query;
  const [formValues, handleInputChange] = useForm({
    searchText: q,
  });
  const { searchText } = formValues;
  // importante: useMemo hace eficiente el uso de la funcion para renderizar
  // de forma controlada
  const heroesFiltered = useMemo(() => getHeroesByName(q), [q]);

  const handleSearch = (e) => {
    e.preventDefault();
    navigate(`?q=${searchText}`);
  };

  return (
    <>
      <h1>Search</h1>
      <hr />
      <div className="row">
        <div className="col-5">
          <form onSubmit={handleSearch}>
            <input
              type="text"
              className="form-control"
              placeholder="Enter your text for search"
              autoComplete="off"
              name="searchText"
              onChange={handleInputChange}
              value={searchText}
            />
            <button type="submit" className="btn btn-dark mt-3">
              Search
            </button>
          </form>
        </div>
        <div className="col-7">
          <h4>Results</h4>
          <hr />
          <div className="row">
            {q === "" ? (
              <div className="alert alert-info animate__animated animate__fadeIn">
                Search for heroes.
              </div>
            ) : (
              heroesFiltered.length === 0 && (
                <div className="alert alert-dark animate__animated animate__fadeIn">
                  No results.
                </div>
              )
            )}
            {heroesFiltered.map((hero) => (
              <HeroCard key={hero.id} hero={hero} />
            ))}
          </div>
        </div>
      </div>
    </>
  );
};


QueryString
===========

Utilitario para trabajar en las búsquedas por término clave.

Instalación:

npm i query-string

Ejemplo en SearchScreen.js:

  /**
   * Uso de hooks para generar la ruta de busqueda y efectuar
   * la busqueda por termino clave
   */
  const navigate = useNavigate();
  const location = useLocation();
  const query = queryString.parse(location.search);
  const { q = "" } = query;
  const [formValues, handleInputChange] = useForm({
    searchText: q,
  });
  const { searchText } = formValues;
  // importante: useMemo hace eficiente el uso de la funcion para renderizar
  // de forma controlada
  const heroesFiltered = useMemo(() => getHeroesByName(q), [q]);

  const handleSearch = (e) => {
    e.preventDefault();
    navigate(`?q=${searchText}`);
  };


Enrutamiento protegido
======================












