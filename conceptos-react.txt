Conceptos clave y distintivos de React JS
=========================================

Componente
----------

Es todo objeto que se visualiza en la aplicación web. Ejemplo:

import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className="App">
      <h1>Hola mundo</h1>
    </div>
  );
}

export default App;

Al crear un proyecto React JS, por defecto crea el componente principal App.js. Si se desea crear un componente principal alternativo, se crearía un archivo de JavaScript y se definiría como sigue:

import logo from './logo.svg';
import './App.css';

function MiComponente() {
  return (
    <div className="App">
      <h1>Hola mundo</h1>
    </div>
  );
}

export default MiComponente;

Renderización del componente principal
--------------------------------------

import React from "react";
import { createRoot } from "react-dom/client"; // ahora se exige en React 18
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

/**
 * Notar que ya no se invoca a la clase ReactDOM ni al metodo render
 * como tradicionalmente se hacía hasta la version 17.
 */
const root = createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

Siguiendo el ejemplo anterior, el componente principal creado, al renderizarse, podría ser MiComponente, el cual podría aparecer de la siguiente forma:

const root = createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <MiComponente />
  </React.StrictMode>
);


Propiedades o "props"
---------------------

Es el concepto clave de React. Los props son, simplemente, las propiedades de un componente hecho en React JS, del mismo modo que conocemos los tags de un bloque HTML como, por ejemplo, el de imagen:

<img src=".png" alt="" border="0" align="left" width="" height="" />

En términos de JSX, img sería un componente y los tags src, alt, border, align, width y height serían los props.

Si, por ejemplo, tenemos un componente llamado Persona en JSX (en App.js o donde se llame al componente):

<Persona nombre="Tino" edad=37 />

Los props serían nombre y edad. En la definición de componente sería:

export function Persona(){
	
	return(
		<>
			Nombre: {this.props.nombre} <br/>
			Edad: {this.props.edad}
		</>
	);
	
}

o, más típicamente:

export function Persona(props){
	
	return(
		<>
			Nombre: {props.nombre} <br/>
			Edad: {props.edad}
		</>
	);
	
}

Pueden tener valores por defecto a través de la creación del objeto defaultProps:

Persona.defaultProps = {
	nombre : "Usuario",
	edad : 25,
}

Los props pueden también recibirse como objeto:

Sea:

const persona = {
nombre: "Tino",
edad: 37,
correo: 'tinoreyna1984@gmail.com'
};

Pasamos persona a un componente como este (en App.js o donde se llame al componente):

<Persona persona={persona} />

El componente leerá la persona de la siguiente forma:

export function Persona(props){
	return(
		<>
			Nombre: {props.persona.nombre} <br/>
			Edad: {props.persona.edad} <br/>
			Correo: {props.persona.correo} 
		</>
	);
}

o:

export function Persona(props){

	// la forma más limpia: desestructurando objetos
	{persona} = props;
	{nombre, edad, correo} = persona;
	
	return(
		<>
			Nombre: {nombre} <br/>
			Edad: {edad} <br/>
			Correo: {correo} 
		</>
	);
}

Los props también pueden incluir funciones:

Sea la función declarada en App.js o en otro componente:

const saludoFn = (nombre) => {
	alert("Hola, " + nombre);
};

Sea el componente declarado en App.js o en otro componente:

<Saludo persona={persona} saludoFn={saludoFn} />

El componente sería el siguiente:

export default function Saludo(props) {

  // Notese que las variables las he obtenido con el operador desestructuracion (llaves)

  const { saludoFn, persona } = props;
  const { nombre = 'Usuario' } = persona; // se le puede asignar tambien un valor por defecto de esta forma

  return (
    <>
      <button onClick={() => saludoFn(nombre)}>Saludar</button>
      {/* el componente genera un botón que emplea un callback, aprovechando la función procedente del props */}
    </>
  );
}

Manejo de eventos
=================

Se tocará lo más típico:

import React, { useState } from "react";
import PropTypes from "prop-types";

export default function AddCategory({setCategories}) {
  // hooks para el campo de texto
  const [inputValue, setInputValue] = useState("");

  // cada vez que cambio el valor en el campo de texto
  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };

  // cada vez que doy enter o cliquee en algun boton para enviar el dato del formulario
  const handleSubmit = (e) => {
    e.preventDefault();
    if(inputValue.trim().length > 2){
        setCategories(categories => [inputValue, ...categories]);
        setInputValue('');
    }
    
  }

  return (
    <form onSubmit={handleSubmit}>
        <input type="text" value={inputValue} onChange={handleInputChange} />
    </form>
  );
}

onChange: evento propio de cambios en campos de texto. Se invoca un callback que determine el valor mapeado en el instante en el que se introduce un nuevo valor en ese objeto.
onSubmit: es para el envío de un conjunto de valores desde formulario.
onClick: ocurre cuando se hace click en un objeto del tipo botón.

Hooks
=====

Referencias:
https://es.reactjs.org/docs/hooks-state.html
https://es.reactjs.org/docs/hooks-effect.html

Son funcionalidades que permiten cambiar dinámica y sencillamente los estados de los props.

Los más típicos son useState y useEffect, los cuales manejan estados y efectos, respectivamente.

Reglas de Hooks:

1. Solo llamar Hooks en el nivel superior. No llamar Hooks dentro de loops, condiciones o funciones anidadas.
2. Solo llamar Hooks desde componentes de función de React. No llamar Hooks desde las funciones regulares de JavaScript. (Solo hay otro lugar válido para llamar Hooks: los Hooks personalizados por el usuario).

Referencia: https://es.reactjs.org/docs/hooks-rules.html

useState
--------

Ejemplo:

import React, { useState } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
       Click me
      </button>
    </div>
  );
}

Línea 1: Importamos el Hook useState desde React que nos permite mantener un estado local en un componente de función.

Línea 4: Dentro del componente Example declaramos una nueva variable de estado llamando al Hook useState. Este nos devuelve un par de valores, a los que damos un nombre. Llamamos count a nuestra variable porque guarda el número de clicks en el botón. La inicializamos a cero pasando 0 como único argumento a useState. El segundo elemento retornado es una función que nos permite actualizar count, por lo que le llamamos setCount.

Línea 9: Cuando el usuario hace click, llamamos a setCount con un nuevo valor. React actualizará entonces el componente Example pasándole el nuevo valor de count.

La logica del useState puede ser definida como la siguiente función:

const useState = (valor) => {
    return [valor, (valor) => {function(valor)}];
}

Para el ejemplo anterior:

/* eslint-disable react-hooks/rules-of-hooks */
import React from 'react';

function Example() {
  const useState = (count) => {
    return [count, (count) => setCount(count)];
  }

  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
       Click me
      </button>
    </div>
  );
}

useEffect
---------

import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // De forma similar a componentDidMount y componentDidUpdate
  useEffect(() => {
    // Actualiza el título del documento usando la API del navegador
    document.title = `Hiciste clic ${count} veces`;
  }, [count]); // count es la única condición que permite la ejecución del hook

  return (
    <div>
      <p>Hiciste clic {count} veces</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

El useEffect nos permite ejecutar un efecto secundario cuando algo sucede en el componente.

Este fragmento está basado en el ejemplo de contador de la página anterior, pero le hemos añadido una funcionalidad nueva: actualizamos el título del documento con un mensaje personalizado que incluye el número de clicks.

El useEffect nos permite ejecutar una instrucción de forma condicionada. El primer argumento es lo que se desea presentar en el renderizado y el segundo argumento es la lista de condiciones por las cuales se permite la ejecución.

useRef
------

Usa el concepto de referencia de un componente, esto es, el atributo ref de un objeto HTML. Se emplea una variable para inicializar con el hook useRef y aprovecharla ante un evento asociado al objeto en cuestión.

Ejemplo:

import React, { useRef } from "react";
import "./effects.css";

export const FocusScreen = () => {
  /**
   * useRef permite almacenar el valor del elemento de foco en una variable
   */
  const inputRef = useRef();
  const handleClick = () => {
    inputRef.current.select();
  };

  return (
    <div>
      <h1>FocusScreen</h1>
      <hr />
      <input
        ref={inputRef}
        className="form-control"
        placeholder="escribe tu nombre"
      />
      <button className="btn btn-outline-primary mt-5" onClick={handleClick}>
        Focus
      </button>
    </div>
  );
};

useLayoutEffect
---------------

Funciona como el useEffect, pero el efecto generado ocurre después de todas las mutaciones en el DOM.
La sintaxis es similar al useEffect.

useMemo
-------

Permite almacenar el valor de la ejecución de un proceso, el cual ocurre de manera controlada.
El nombre del hook viene a que este memoriza ese proceso para optimizar el desempeño del app.

Ejemplo:

import React, { useMemo, useState } from "react";
import "./effects.css";
import { useCounter } from "../../hooks/useCounter";
import { procesoPesado } from "../../helpers/procesoPesado";

export const MemoHook = () => {
  const { counter, increment } = useCounter(5000);
  const [show, setShow] = useState(true);



  /**
   * useMemo: hook que permite devolver un valor memorizado a partir de un proceso
   * y un conjunto de condiciones que lo controlan
   */
  const memoProcesoPesado = useMemo(() => procesoPesado(counter), [counter]);

  return (
    <div>
        <h1>MemoHook</h1>
      <h3>
        Counter: <small>{counter}</small>
      </h3>
      <hr />
      <p>{memoProcesoPesado}</p>
      <button className="btn btn-primary" onClick={increment}>
        +1
      </button>
      <button
        className="btn btn-outline-primary ml-3"
        onClick={() => setShow(!show)}
      >
        Show/hide {JSON.stringify(show)}
      </button>
    </div>
  );
};

useCallback
-----------

Devuelve un callback memorizado.
Ejemplo:

ShowIncrement.js:

import React from "react";

export const ShowIncrement = React.memo(({ increment }) => {
  console.log("Me volví a generar.");
  return (
    <button
      className="btn btn-outline-primary"
      onClick={() => {
        increment(5);
      }}
    >
      Incrementar
    </button>
  );
});

CallbackHook.js:

import React, { useCallback, useState } from "react";
import "./effects.css";
import { ShowIncrement } from "./ShowIncrement";

export const CallbackHook = () => {
  const [counter, setCounter] = useState(10);

  /* const increment = () => {
    setCounter(counter + 1);
  }; */

  /**
   * useCallback: devuelve un callback memorizado
   */
  const increment = useCallback(
    (num) => {
        setCounter((c) => c + num);
    },
    [setCounter],
  )
  

  return (
    <div>
      <h1>useCallbackHook: {counter}</h1>
      <hr />
      <ShowIncrement increment={increment} />
    </div>
  );
};




React.memo
==========

Optimiza el renderizado de un componente con los mismos valores de props ingresados.
Ejemplo:

Small.js:

import React from 'react';

export const Small = React.memo(({value}) => {
  console.log("Me volvi a llamar");
  return (
    <small>{value}</small>
  )
});

Memorize.js: (llama al componente memorizado Small)

import React, { useState } from "react";
import "./effects.css";
import { useCounter } from "../../hooks/useCounter";
import {Small} from "./Small";

export const Memorize = () => {
  const { counter, increment } = useCounter(10);
  const [show, setShow] = useState(true);

  return (
    <div>
      <h1>
        Counter: <Small value={counter} />{" "}
      </h1>
      <hr />
      <button className="btn btn-primary" onClick={increment}>
        +1
      </button>
      <button
        className="btn btn-outline-primary ml-3"
        onClick={() => setShow(!show)}
      >
        Show/hide {JSON.stringify(show)}
      </button>
    </div>
  );
};













